(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global.SEMaaS = factory());
}(this, (function () { 'use strict';

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };

  var asyncToGenerator = function (fn) {
    return function () {
      var gen = fn.apply(this, arguments);
      return new Promise(function (resolve, reject) {
        function step(key, arg) {
          try {
            var info = gen[key](arg);
            var value = info.value;
          } catch (error) {
            reject(error);
            return;
          }

          if (info.done) {
            resolve(value);
          } else {
            return Promise.resolve(value).then(function (value) {
              step("next", value);
            }, function (err) {
              step("throw", err);
            });
          }
        }

        return step("next");
      });
    };
  };

  var classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  var createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  var defineProperty = function (obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  };

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  var toConsumableArray = function (arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    } else {
      return Array.from(arr);
    }
  };

  /**
   * Copyright (c) 2014-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  !function (global) {

    var Op = Object.prototype;
    var hasOwn = Op.hasOwnProperty;
    var undefined; // More compressible than void 0.
    var $Symbol = typeof Symbol === "function" ? Symbol : {};
    var iteratorSymbol = $Symbol.iterator || "@@iterator";
    var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
    var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

    var inModule = (typeof module === "undefined" ? "undefined" : _typeof(module)) === "object";
    var runtime = global.regeneratorRuntime;
    if (runtime) {
      if (inModule) {
        // If regeneratorRuntime is defined globally and we're in a module,
        // make the exports object identical to regeneratorRuntime.
        module.exports = runtime;
      }
      // Don't bother evaluating the rest of this file if the runtime was
      // already defined globally.
      return;
    }

    // Define the runtime globally (as expected by generated code) as either
    // module.exports (if we're in a module) or a new, empty object.
    runtime = global.regeneratorRuntime = inModule ? module.exports : {};

    function wrap(innerFn, outerFn, self, tryLocsList) {
      // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
      var generator = Object.create(protoGenerator.prototype);
      var context = new Context(tryLocsList || []);

      // The ._invoke method unifies the implementations of the .next,
      // .throw, and .return methods.
      generator._invoke = makeInvokeMethod(innerFn, self, context);

      return generator;
    }
    runtime.wrap = wrap;

    // Try/catch helper to minimize deoptimizations. Returns a completion
    // record like context.tryEntries[i].completion. This interface could
    // have been (and was previously) designed to take a closure to be
    // invoked without arguments, but in all the cases we care about we
    // already have an existing method we want to call, so there's no need
    // to create a new function object. We can even get away with assuming
    // the method takes exactly one argument, since that happens to be true
    // in every case, so we don't have to touch the arguments object. The
    // only additional allocation required is the completion record, which
    // has a stable shape and so hopefully should be cheap to allocate.
    function tryCatch(fn, obj, arg) {
      try {
        return { type: "normal", arg: fn.call(obj, arg) };
      } catch (err) {
        return { type: "throw", arg: err };
      }
    }

    var GenStateSuspendedStart = "suspendedStart";
    var GenStateSuspendedYield = "suspendedYield";
    var GenStateExecuting = "executing";
    var GenStateCompleted = "completed";

    // Returning this object from the innerFn has the same effect as
    // breaking out of the dispatch switch statement.
    var ContinueSentinel = {};

    // Dummy constructor functions that we use as the .constructor and
    // .constructor.prototype properties for functions that return Generator
    // objects. For full spec compliance, you may wish to configure your
    // minifier not to mangle the names of these two functions.
    function Generator() {}
    function GeneratorFunction() {}
    function GeneratorFunctionPrototype() {}

    // This is a polyfill for %IteratorPrototype% for environments that
    // don't natively support it.
    var IteratorPrototype = {};
    IteratorPrototype[iteratorSymbol] = function () {
      return this;
    };

    var getProto = Object.getPrototypeOf;
    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
      // This environment has a native %IteratorPrototype%; use it instead
      // of the polyfill.
      IteratorPrototype = NativeIteratorPrototype;
    }

    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
    GeneratorFunctionPrototype.constructor = GeneratorFunction;
    GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";

    // Helper for defining the .next, .throw, and .return methods of the
    // Iterator interface in terms of a single ._invoke method.
    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function (method) {
        prototype[method] = function (arg) {
          return this._invoke(method, arg);
        };
      });
    }

    runtime.isGeneratorFunction = function (genFun) {
      var ctor = typeof genFun === "function" && genFun.constructor;
      return ctor ? ctor === GeneratorFunction ||
      // For the native GeneratorFunction constructor, the best we can
      // do is to check its .name property.
      (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
    };

    runtime.mark = function (genFun) {
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
      } else {
        genFun.__proto__ = GeneratorFunctionPrototype;
        if (!(toStringTagSymbol in genFun)) {
          genFun[toStringTagSymbol] = "GeneratorFunction";
        }
      }
      genFun.prototype = Object.create(Gp);
      return genFun;
    };

    // Within the body of any async function, `await x` is transformed to
    // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
    // `hasOwn.call(value, "__await")` to determine if the yielded value is
    // meant to be awaited.
    runtime.awrap = function (arg) {
      return { __await: arg };
    };

    function AsyncIterator(generator) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);
        if (record.type === "throw") {
          reject(record.arg);
        } else {
          var result = record.arg;
          var value = result.value;
          if (value && (typeof value === "undefined" ? "undefined" : _typeof(value)) === "object" && hasOwn.call(value, "__await")) {
            return Promise.resolve(value.__await).then(function (value) {
              invoke("next", value, resolve, reject);
            }, function (err) {
              invoke("throw", err, resolve, reject);
            });
          }

          return Promise.resolve(value).then(function (unwrapped) {
            // When a yielded Promise is resolved, its final value becomes
            // the .value of the Promise<{value,done}> result for the
            // current iteration. If the Promise is rejected, however, the
            // result for this iteration will be rejected with the same
            // reason. Note that rejections of yielded Promises are not
            // thrown back into the generator function, as is the case
            // when an awaited Promise is rejected. This difference in
            // behavior between yield and await is important, because it
            // allows the consumer to decide what to do with the yielded
            // rejection (swallow it and continue, manually .throw it back
            // into the generator, abandon iteration, whatever). With
            // await, by contrast, there is no opportunity to examine the
            // rejection reason outside the generator function, so the
            // only option is to throw it from the await expression, and
            // let the generator function handle the exception.
            result.value = unwrapped;
            resolve(result);
          }, reject);
        }
      }

      var previousPromise;

      function enqueue(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new Promise(function (resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }

        return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(callInvokeWithMethodAndArg,
        // Avoid propagating failures to Promises returned by later
        // invocations of the iterator.
        callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }

      // Define the unified helper method that is used to implement .next,
      // .throw, and .return (see defineIteratorMethods).
      this._invoke = enqueue;
    }

    defineIteratorMethods(AsyncIterator.prototype);
    AsyncIterator.prototype[asyncIteratorSymbol] = function () {
      return this;
    };
    runtime.AsyncIterator = AsyncIterator;

    // Note that simple async functions are implemented on top of
    // AsyncIterator objects; they just return a Promise for the value of
    // the final result produced by the iterator.
    runtime.async = function (innerFn, outerFn, self, tryLocsList) {
      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));

      return runtime.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function (result) {
        return result.done ? result.value : iter.next();
      });
    };

    function makeInvokeMethod(innerFn, self, context) {
      var state = GenStateSuspendedStart;

      return function invoke(method, arg) {
        if (state === GenStateExecuting) {
          throw new Error("Generator is already running");
        }

        if (state === GenStateCompleted) {
          if (method === "throw") {
            throw arg;
          }

          // Be forgiving, per 25.3.3.3.3 of the spec:
          // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
          return doneResult();
        }

        context.method = method;
        context.arg = arg;

        while (true) {
          var delegate = context.delegate;
          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);
            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }

          if (context.method === "next") {
            // Setting context._sent for legacy support of Babel's
            // function.sent implementation.
            context.sent = context._sent = context.arg;
          } else if (context.method === "throw") {
            if (state === GenStateSuspendedStart) {
              state = GenStateCompleted;
              throw context.arg;
            }

            context.dispatchException(context.arg);
          } else if (context.method === "return") {
            context.abrupt("return", context.arg);
          }

          state = GenStateExecuting;

          var record = tryCatch(innerFn, self, context);
          if (record.type === "normal") {
            // If an exception is thrown from innerFn, we leave state ===
            // GenStateExecuting and loop back for another invocation.
            state = context.done ? GenStateCompleted : GenStateSuspendedYield;

            if (record.arg === ContinueSentinel) {
              continue;
            }

            return {
              value: record.arg,
              done: context.done
            };
          } else if (record.type === "throw") {
            state = GenStateCompleted;
            // Dispatch the exception by looping back around to the
            // context.dispatchException(context.arg) call above.
            context.method = "throw";
            context.arg = record.arg;
          }
        }
      };
    }

    // Call delegate.iterator[context.method](context.arg) and handle the
    // result, either by returning a { value, done } result from the
    // delegate iterator, or by modifying context.method and context.arg,
    // setting context.delegate to null, and returning the ContinueSentinel.
    function maybeInvokeDelegate(delegate, context) {
      var method = delegate.iterator[context.method];
      if (method === undefined) {
        // A .throw or .return when the delegate iterator has no .throw
        // method always terminates the yield* loop.
        context.delegate = null;

        if (context.method === "throw") {
          if (delegate.iterator.return) {
            // If the delegate iterator has a return method, give it a
            // chance to clean up.
            context.method = "return";
            context.arg = undefined;
            maybeInvokeDelegate(delegate, context);

            if (context.method === "throw") {
              // If maybeInvokeDelegate(context) changed context.method from
              // "return" to "throw", let that override the TypeError below.
              return ContinueSentinel;
            }
          }

          context.method = "throw";
          context.arg = new TypeError("The iterator does not provide a 'throw' method");
        }

        return ContinueSentinel;
      }

      var record = tryCatch(method, delegate.iterator, context.arg);

      if (record.type === "throw") {
        context.method = "throw";
        context.arg = record.arg;
        context.delegate = null;
        return ContinueSentinel;
      }

      var info = record.arg;

      if (!info) {
        context.method = "throw";
        context.arg = new TypeError("iterator result is not an object");
        context.delegate = null;
        return ContinueSentinel;
      }

      if (info.done) {
        // Assign the result of the finished delegate to the temporary
        // variable specified by delegate.resultName (see delegateYield).
        context[delegate.resultName] = info.value;

        // Resume execution at the desired location (see delegateYield).
        context.next = delegate.nextLoc;

        // If context.method was "throw" but the delegate handled the
        // exception, let the outer generator proceed normally. If
        // context.method was "next", forget context.arg since it has been
        // "consumed" by the delegate iterator. If context.method was
        // "return", allow the original .return call to continue in the
        // outer generator.
        if (context.method !== "return") {
          context.method = "next";
          context.arg = undefined;
        }
      } else {
        // Re-yield the result returned by the delegate method.
        return info;
      }

      // The delegate iterator is finished, so forget it and continue with
      // the outer generator.
      context.delegate = null;
      return ContinueSentinel;
    }

    // Define Generator.prototype.{next,throw,return} in terms of the
    // unified ._invoke helper method.
    defineIteratorMethods(Gp);

    Gp[toStringTagSymbol] = "Generator";

    // A Generator should always return itself as the iterator object when the
    // @@iterator function is called on it. Some browsers' implementations of the
    // iterator prototype chain incorrectly implement this, causing the Generator
    // object to not be returned from this call. This ensures that doesn't happen.
    // See https://github.com/facebook/regenerator/issues/274 for more details.
    Gp[iteratorSymbol] = function () {
      return this;
    };

    Gp.toString = function () {
      return "[object Generator]";
    };

    function pushTryEntry(locs) {
      var entry = { tryLoc: locs[0] };

      if (1 in locs) {
        entry.catchLoc = locs[1];
      }

      if (2 in locs) {
        entry.finallyLoc = locs[2];
        entry.afterLoc = locs[3];
      }

      this.tryEntries.push(entry);
    }

    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal";
      delete record.arg;
      entry.completion = record;
    }

    function Context(tryLocsList) {
      // The root entry object (effectively a try statement without a catch
      // or a finally block) gives us a place to store values thrown from
      // locations where there is no enclosing try statement.
      this.tryEntries = [{ tryLoc: "root" }];
      tryLocsList.forEach(pushTryEntry, this);
      this.reset(true);
    }

    runtime.keys = function (object) {
      var keys = [];
      for (var key in object) {
        keys.push(key);
      }
      keys.reverse();

      // Rather than returning an object with a next method, we keep
      // things simple and return the next function itself.
      return function next() {
        while (keys.length) {
          var key = keys.pop();
          if (key in object) {
            next.value = key;
            next.done = false;
            return next;
          }
        }

        // To avoid creating an additional object, we just hang the .value
        // and .done properties off the next function object itself. This
        // also ensures that the minifier will not anonymize the function.
        next.done = true;
        return next;
      };
    };

    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod) {
          return iteratorMethod.call(iterable);
        }

        if (typeof iterable.next === "function") {
          return iterable;
        }

        if (!isNaN(iterable.length)) {
          var i = -1,
              next = function next() {
            while (++i < iterable.length) {
              if (hasOwn.call(iterable, i)) {
                next.value = iterable[i];
                next.done = false;
                return next;
              }
            }

            next.value = undefined;
            next.done = true;

            return next;
          };

          return next.next = next;
        }
      }

      // Return an iterator with no values.
      return { next: doneResult };
    }
    runtime.values = values;

    function doneResult() {
      return { value: undefined, done: true };
    }

    Context.prototype = {
      constructor: Context,

      reset: function reset(skipTempReset) {
        this.prev = 0;
        this.next = 0;
        // Resetting context._sent for legacy support of Babel's
        // function.sent implementation.
        this.sent = this._sent = undefined;
        this.done = false;
        this.delegate = null;

        this.method = "next";
        this.arg = undefined;

        this.tryEntries.forEach(resetTryEntry);

        if (!skipTempReset) {
          for (var name in this) {
            // Not sure about the optimal order of these conditions:
            if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
              this[name] = undefined;
            }
          }
        }
      },

      stop: function stop() {
        this.done = true;

        var rootEntry = this.tryEntries[0];
        var rootRecord = rootEntry.completion;
        if (rootRecord.type === "throw") {
          throw rootRecord.arg;
        }

        return this.rval;
      },

      dispatchException: function dispatchException(exception) {
        if (this.done) {
          throw exception;
        }

        var context = this;
        function handle(loc, caught) {
          record.type = "throw";
          record.arg = exception;
          context.next = loc;

          if (caught) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            context.method = "next";
            context.arg = undefined;
          }

          return !!caught;
        }

        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          var record = entry.completion;

          if (entry.tryLoc === "root") {
            // Exception thrown outside of any try block that could handle
            // it, so set the completion value of the entire function to
            // throw the exception.
            return handle("end");
          }

          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc");
            var hasFinally = hasOwn.call(entry, "finallyLoc");

            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              } else if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              }
            } else if (hasFinally) {
              if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else {
              throw new Error("try statement without catch or finally");
            }
          }
        }
      },

      abrupt: function abrupt(type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }

        if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
          // Ignore the finally entry if control is not jumping to a
          // location outside the try/catch block.
          finallyEntry = null;
        }

        var record = finallyEntry ? finallyEntry.completion : {};
        record.type = type;
        record.arg = arg;

        if (finallyEntry) {
          this.method = "next";
          this.next = finallyEntry.finallyLoc;
          return ContinueSentinel;
        }

        return this.complete(record);
      },

      complete: function complete(record, afterLoc) {
        if (record.type === "throw") {
          throw record.arg;
        }

        if (record.type === "break" || record.type === "continue") {
          this.next = record.arg;
        } else if (record.type === "return") {
          this.rval = this.arg = record.arg;
          this.method = "return";
          this.next = "end";
        } else if (record.type === "normal" && afterLoc) {
          this.next = afterLoc;
        }

        return ContinueSentinel;
      },

      finish: function finish(finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.finallyLoc === finallyLoc) {
            this.complete(entry.completion, entry.afterLoc);
            resetTryEntry(entry);
            return ContinueSentinel;
          }
        }
      },

      "catch": function _catch(tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;
            if (record.type === "throw") {
              var thrown = record.arg;
              resetTryEntry(entry);
            }
            return thrown;
          }
        }

        // The context.catch method must only be called with a location
        // argument that corresponds to a known catch block.
        throw new Error("illegal catch attempt");
      },

      delegateYield: function delegateYield(iterable, resultName, nextLoc) {
        this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        };

        if (this.method === "next") {
          // Deliberately forget the last sent value so that we don't
          // accidentally pass it on to the delegate.
          this.arg = undefined;
        }

        return ContinueSentinel;
      }
    };
  }(
  // In sloppy mode, unbound `this` refers to the global object, fallback to
  // Function constructor if we're in global strict mode. That is sadly a form
  // of indirect eval which violates Content Security Policy.
  function () {
    return this;
  }() || Function("return this")());

  var SEMAAS_REQUIRED_FIELDS = ['consumerId', 'policy', 'mrId', 'nameSpace', 'region', 'dnsTld', 'tsec2JWTEndpoint', 'tsecStorageKey'];

  var SEMAAS = {
    DEFAULT_ADAPTER_IDENTIFIER: 'application',
    DEFAULT_ADAPTER_VERSION: 'v1',
    REQUIRED_FIELDS: SEMAAS_REQUIRED_FIELDS,
    ALLOWED_FIELDS: [].concat(SEMAAS_REQUIRED_FIELDS, ['identifier', 'version', 'logLevel'])
  };

  var buildServiceUri = function buildServiceUri(codename) {
    return function (region, dnsTld, version) {
      return 'https://' + codename + '.' + [region, dnsTld].filter(Boolean).join('.') + '/' + version;
    };
  };

  var RHO = {
    HOST: buildServiceUri('rho'),
    ALLOWED_FIELDS: ['mrId', 'spanId', 'startDate', 'finishDate', 'name', 'parentSpan', 'traceId', 'properties', 'duration', 'recordDate'],
    REQUIRED_FIELDS: []
  };

  var DEFAULT_LOG_LEVEL = 'debug';

  var OMEGA = {
    HOST: buildServiceUri('omega'),
    DEFAULT_LOG_LEVEL: DEFAULT_LOG_LEVEL,
    ALLOWED_FIELDS: ['mrId', 'spanId', 'traceId', 'creationDate', 'level', 'message', 'properties'],
    MAXIMUM_BULK_SIZE: 1000,
    REQUIRED_FIELDS: [],
    LOG_LEVELS: [DEFAULT_LOG_LEVEL, 'info', 'warn', 'warning', 'error', 'fatal']
  };

  // const TSEC2JWT = {
  //   HOST: environment => `https://tsec2jwt.smlb.${environment}.meigas.cloud/v1/Token`,
  // };

  var Constants = {
    SEMAAS: SEMAAS,
    RHO: RHO,
    OMEGA: OMEGA
    // TSEC2JWT,
  };

  // credits to GeenenTijd/dotify
  // https://github.com/GeenenTijd/dotify/blob/master/dotify.js
  var dotify = function dotify(obj) {
    var SEPARATOR_KEY = '_';
    var res = {};
    var recurse = function recurse(obj, current) {
      Object.keys(obj).forEach(function (key) {
        var value = obj[key];
        var newKey = current ? current + SEPARATOR_KEY + key : key; // joined key with dot
        if (value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
          recurse(value, newKey); // it's a nested object, so do it again
        } else {
          res[newKey] = value; // it's not an object, so set the property
        }
      });
    };

    recurse(obj);
    return res;
  };
  var sanitizeObj = function sanitizeObj(obj, allowedFields) {
    var result = _extends({}, obj);

    Object.keys(result).forEach(function (prop) {
      if (!allowedFields.includes(prop)) {
        delete result[prop];
      }
    });

    if (result.properties) {
      result.properties = dotify(result.properties);
    }

    return result;
  };
  var hasProperty = function hasProperty(obj) {
    return function (field) {
      return Object.prototype.hasOwnProperty.call(obj, field) && !!obj[field];
    };
  };
  var hasProperties = function hasProperties(obj, expectedFields) {
    return expectedFields.every(hasProperty(obj));
  };
  var groupBy = function groupBy(items, value) {
    return items.reduce(function (prev, current) {
      var key = value instanceof Function ? value(current) : current[value];
      var itemsContainingKey = prev.find(function (r) {
        return r && r.key === key;
      });

      if (itemsContainingKey) {
        itemsContainingKey.values.push(current);
      } else {
        prev.push({ key: key, values: [current] });
      }

      return prev;
    }, []);
  };
  var createUUID = function createUUID() {
    var s = [];
    var hexDigits = '0123456789abcdef';
    for (var i = 0; i < 36; i++) {
      s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
    }
    s[14] = '4'; // bits 12-15 of the time_hi_and_version field to 0010
    s[19] = hexDigits.substr(s[19] & 0x3 | 0x8, 1); // bits 6-7 of the clock_seq_hi_and_reserved to 01
    s[8] = s[13] = s[18] = s[23] = '-';

    var uuid = s.join('');
    return uuid;
  };

  var Utils = {
    dotify: dotify,
    sanitizeObj: sanitizeObj,
    hasProperty: hasProperty,
    hasProperties: hasProperties,
    groupBy: groupBy,
    createUUID: createUUID
  };

  var OMEGA$1 = Constants.OMEGA;
  var DEFAULT_LOG_LEVEL$1 = OMEGA$1.DEFAULT_LOG_LEVEL,
      ALLOWED_FIELDS = OMEGA$1.ALLOWED_FIELDS;
  var sanitizeObj$1 = Utils.sanitizeObj;

  var Omega = function () {
    function Omega(mrId) {
      classCallCheck(this, Omega);

      this.mrId = mrId;
    }

    // @TODO renombrar a normalizeLog? buildLog?
    /* static */


    createClass(Omega, [{
      key: 'createLog',
      value: function createLog(obj) {
        var mrId = this.mrId;

        var sanitizedData = sanitizeObj$1(obj, ALLOWED_FIELDS);
        var DEFAULT_LOG = {
          mrId: mrId,
          creationDate: Date.now() * 1000000,
          level: DEFAULT_LOG_LEVEL$1
        };

        return _extends({}, DEFAULT_LOG, sanitizedData);
      }
    }]);
    return Omega;
  }();

  var RHO$1 = Constants.RHO;
  var ALLOWED_FIELDS$1 = RHO$1.ALLOWED_FIELDS;
  var sanitizeObj$2 = Utils.sanitizeObj,
      _createUUID = Utils.createUUID;

  var Span = function () {
    function Span(config) {
      classCallCheck(this, Span);

      this.spanId = null;
      this.initialize(config);
    }

    createClass(Span, [{
      key: 'initialize',
      value: function initialize(config) {
        var _this = this;

        ALLOWED_FIELDS$1.forEach(function (field) {
          if (config[field]) {
            _this[field] = config[field];
          }
        });

        this.spanId = _createUUID();
        this.start();
      }
    }, {
      key: 'start',
      value: function start() {
        this.startDate = Date.now() * 1000000;
      }
    }, {
      key: 'finish',
      value: function finish() {
        this.finishDate = Date.now() * 1000000;
      }
    }]);
    return Span;
  }();

  var Rho = function () {
    function Rho(mrId) {
      classCallCheck(this, Rho);

      this.mrId = mrId;
    }

    createClass(Rho, [{
      key: 'createUUID',
      value: function createUUID() {
        return _createUUID();
      }
    }, {
      key: 'createSpan',
      value: function createSpan(rawData, childSpanPrefix) {
        var DEFAULT_MR_ID = this.mrId;
        var _rawData$mrId = rawData.mrId,
            mrId = _rawData$mrId === undefined ? DEFAULT_MR_ID : _rawData$mrId,
            parentSpan = rawData.parentSpan;

        var normalizedParentSpan = this.getParentSpan(parentSpan, mrId, childSpanPrefix);
        var data = _extends({}, rawData, {
          mrId: mrId,
          parentSpan: normalizedParentSpan
        });
        var span = new Span(data);

        return span;
      }
    }, {
      key: 'buildSpans',
      value: function buildSpans(data) {
        var iterableData = Array.isArray(data) ? [].concat(toConsumableArray(data)) : [data];

        return iterableData.map(function (item) {
          return sanitizeObj$2(item, ALLOWED_FIELDS$1);
        });
      }
    }, {
      key: 'getParentSpan',
      value: function getParentSpan(parentSpan, mrId, childSpanPrefix) {
        if (!parentSpan) {
          return null;
        }

        return [childSpanPrefix, mrId, 'spans', parentSpan].join('/');
      }
    }]);
    return Rho;
  }();

  var Adapters = {
    Omega: Omega,
    Rho: Rho
  };

  function request(method) {
    var _this = this;

    return function () {
      var _ref = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(options) {
        var url, body, headers, configuration, response, result;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                url = options.url, body = options.body, headers = options.headers;
                configuration = {
                  method: method,
                  body: JSON.stringify(body),
                  headers: {
                    'content-type': 'application/json'
                  }
                };


                if (headers) {
                  Object.keys(headers).forEach(function (header) {
                    var headerValue = headers[header];

                    configuration.headers[header] = headerValue;
                  });
                }

                // OJO!!!
                // Interceptar aquí errores
                _context.next = 5;
                return fetch(url, configuration);

              case 5:
                response = _context.sent;
                result = {};
                _context.prev = 7;
                _context.next = 10;
                return response.json();

              case 10:
                result = _context.sent;
                _context.next = 15;
                break;

              case 13:
                _context.prev = 13;
                _context.t0 = _context['catch'](7);

              case 15:
                if (!(!response.ok && result && result.status !== 400)) {
                  _context.next = 17;
                  break;
                }

                return _context.abrupt('return', null);

              case 17:
                return _context.abrupt('return', result);

              case 18:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, _this, [[7, 13]]);
      }));

      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }();
  }

  var METHODS = {
    GET: request('get'),
    POST: request('post')
  };

  var Connector = function () {
    function Connector() {
      classCallCheck(this, Connector);
    }

    createClass(Connector, null, [{
      key: 'get',
      value: function () {
        var _ref2 = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(url, headers) {
          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  return _context2.abrupt('return', METHODS.GET({ url: url, headers: headers }));

                case 1:
                case 'end':
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function get$$1(_x2, _x3) {
          return _ref2.apply(this, arguments);
        }

        return get$$1;
      }()
    }, {
      key: 'post',
      value: function () {
        var _ref3 = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(url, body, headers) {
          return regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  return _context3.abrupt('return', METHODS.POST({ url: url, body: body, headers: headers }));

                case 1:
                case 'end':
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));

        function post(_x4, _x5, _x6) {
          return _ref3.apply(this, arguments);
        }

        return post;
      }()
    }]);
    return Connector;
  }();

  /** Default debounce duration (in ms) */
  var DEFAULT_DEBOUNCE_DURATION = 500;

  /** Decorates a class method so that it is debounced by the specified duration */
  function outerDecorator(duration) {
    return function innerDecorator(target, key, descriptor) {
      return {
        configurable: true,
        enumerable: descriptor.enumerable,
        get: function getter() {
          // Attach this function to the instance (not the class)
          Object.defineProperty(this, key, {
            configurable: true,
            enumerable: descriptor.enumerable,
            value: debounce(descriptor.value, duration)
          });

          return this[key];
        }
      };
    };
  }

  /** Debounces the specified function and returns a wrapper function */
  function debounce(method) {
    var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_DEBOUNCE_DURATION;

    var timeoutId = void 0;

    function debounceWrapper() {
      var _this = this;

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      debounceWrapper.clear();

      timeoutId = setTimeout(function () {
        timeoutId = null;
        method.apply(_this, args);
      }, duration);
    }

    debounceWrapper.clear = function () {
      if (timeoutId) {
        clearTimeout(timeoutId);
        timeoutId = null;
      }
    };

    return debounceWrapper;
  }

  var decorate = function decorate(decorators) {
    return function (obj, prop, descriptor) {
      var fn = descriptor.value;

      decorators.slice().reverse().forEach(function (decorator) {
        return fn = decorator(fn);
      });

      return _extends({}, descriptor, {
        value: fn
      });
    };
  };

  var Decorators = {
    outerDecorator: outerDecorator,
    decorate: decorate
  };

  var groupBy$1 = Utils.groupBy;


  var MAXIMUM_BULK_SIZE = 1000;

  var Queue = function () {
    // maximumBulkSize = null;

    function Queue(identifier) {
      classCallCheck(this, Queue);

      this.items = [];
      this.identifier = identifier;
    }

    createClass(Queue, [{
      key: 'add',
      value: function add(endpoint, data) {
        var _this = this;

        var iterableData = Array.isArray(data) ? [].concat(toConsumableArray(data)) : [data];

        iterableData.forEach(function (item) {
          var operation = {
            data: item,
            endpoint: endpoint
          };

          _this.items.push(operation);
        });
      }
    }, {
      key: 'dump',
      value: function dump() /* maximumBulkSize */{
        if (!this.any()) {
          return null;
        }

        var queueGroupedByEndpoint = groupBy$1(this.items, 'endpoint');
        var firstQueueGroup = queueGroupedByEndpoint[0].values;

        var bulk = firstQueueGroup.slice(0, MAXIMUM_BULK_SIZE);
        var newQueue = this.items.filter(function (item) {
          return !bulk.includes(item);
        });

        console.log('Dumping ' + bulk.length + ' items from ' + this.identifier + ' queue (' + this.items.length + ')...');

        this.items = newQueue;

        return bulk;
      }
    }, {
      key: 'any',
      value: function any() {
        return this.items !== null && this.items.length > 0;
      }
    }]);
    return Queue;
  }();

  var _dec, _class;

  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object['ke' + 'ys'](descriptor).forEach(function (key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;

    if ('value' in desc || desc.initializer) {
      desc.writable = true;
    }

    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
      return decorator(target, property, desc) || desc;
    }, desc);

    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = undefined;
    }

    if (desc.initializer === void 0) {
      Object['define' + 'Property'](target, property, desc);
      desc = null;
    }

    return desc;
  }

  var Omega$1 = Adapters.Omega,
      Rho$1 = Adapters.Rho;
  var _Constants$SEMAAS = Constants.SEMAAS,
      REQUIRED_FIELDS = _Constants$SEMAAS.REQUIRED_FIELDS,
      ALLOWED_FIELDS$2 = _Constants$SEMAAS.ALLOWED_FIELDS,
      DEFAULT_ADAPTER_IDENTIFIER = _Constants$SEMAAS.DEFAULT_ADAPTER_IDENTIFIER,
      DEFAULT_ADAPTER_VERSION = _Constants$SEMAAS.DEFAULT_ADAPTER_VERSION,
      _Constants$OMEGA = Constants.OMEGA,
      OMEGA_HOST = _Constants$OMEGA.HOST,
      DEFAULT_LOG_LEVEL$2 = _Constants$OMEGA.DEFAULT_LOG_LEVEL,
      LOG_LEVELS = _Constants$OMEGA.LOG_LEVELS,
      RHO_HOST = Constants.RHO.HOST;
  var hasProperties$1 = Utils.hasProperties;
  var outerDecorator$1 = Decorators.outerDecorator;
  var SEMaaS = (_dec = outerDecorator$1(5000), (_class = function () {
    function SEMaaS(config) {
      classCallCheck(this, SEMaaS);

      // configurable properties by constructor
      this.nameSpace = null;

      this.identifier = DEFAULT_ADAPTER_IDENTIFIER;

      this.mrId = null;

      this.consumerId = null;

      this.policy = null;

      this.region = null;

      this.dnsTld = null;

      this.version = DEFAULT_ADAPTER_VERSION;

      this.tsec2JWTEndpoint = null;

      this.logLevel = DEFAULT_LOG_LEVEL$2;

      // properties that belong to semaas life cycle and rely on configurable properties
      this.apiKey = null;

      // composition entitys
      this.omega = null;

      this.rho = null;

      this.queue = null;

      this.tsecStorageKey = 'tsec'; // sessionStorage key for recovery the tsec id
      this.setup(config);
    }

    createClass(SEMaaS, [{
      key: 'setup',
      value: function setup(config) {
        if (!config || !this.validateConfig(config, REQUIRED_FIELDS)) {
          throw new Error('Invalid setup for SEMaaS adapter (' + this.identifier + '). Required fields: ' + REQUIRED_FIELDS.join(', ') + '.');
        }

        this.initialize(config);
      }
    }, {
      key: 'validateConfig',
      value: function validateConfig(config, expectedFields) {
        return hasProperties$1(config, expectedFields);
      }
    }, {
      key: 'initialize',
      value: function initialize(config) {
        var _this = this;

        ALLOWED_FIELDS$2.forEach(function (field) {
          if (config[field]) {
            _this[field] = config[field];
          }
        });

        var nameSpace = this.nameSpace,
            identifier = this.identifier,
            mrId = this.mrId,
            tsec2JWTEndpoint = this.tsec2JWTEndpoint,
            region = this.region,
            dnsTld = this.dnsTld,
            version = this.version,
            logLevel = this.logLevel,
            tsecStorageKey = this.tsecStorageKey;


        this.omega = new Omega$1(mrId);
        this.rho = new Rho$1(mrId);
        this.queue = new Queue(identifier);

        console.info('SEMaaS adapter for ' + region + ' (TSEC: ' + tsec2JWTEndpoint + ') [' + dnsTld + ' - ' + version + '] (' + identifier + ' - ns: ' + nameSpace + ', mrId: ' + mrId + ') [logLevel: ' + logLevel + '] [tsecStorageKey: ' + tsecStorageKey + '] successfully initialized.');
      }
    }, {
      key: 'log',
      value: function log(obj) {
        var data = this.omega.createLog(obj);

        if (this.shouldIncludeLog(data.level, this.logLevel)) {
          this.enqueue(this.omegaEndpoint, data);
        }
      }
    }, {
      key: 'ingest',
      value: function ingest(spans) {
        var data = this.rho.buildSpans(spans);

        this.enqueue(this.rhoEndpoint, data);
      }
    }, {
      key: 'createSpan',
      value: function createSpan(data) {
        var span = this.rho.createSpan(data, this.prefixForChildSpan);

        return span;
      }
    }, {
      key: 'createUUID',
      value: function createUUID() {
        var UUID = this.rho.createUUID();

        return UUID;
      }
    }, {
      key: 'send',
      value: function () {
        var _ref = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(url, body, headers) {
          var result;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  result = void 0;
                  _context.prev = 1;
                  _context.next = 4;
                  return Connector.post(url, body, headers);

                case 4:
                  result = _context.sent;
                  _context.next = 9;
                  break;

                case 7:
                  _context.prev = 7;
                  _context.t0 = _context['catch'](1);

                case 9:
                  if (result) {
                    _context.next = 14;
                    break;
                  }

                  console.log('There was a problem while sending data to SEMaaS - operation will be queued.');
                  this.enqueue(url, body);
                  _context.next = 16;
                  break;

                case 14:
                  if (!(result.status === 400)) {
                    _context.next = 16;
                    break;
                  }

                  throw new Error(result.message);

                case 16:
                  return _context.abrupt('return', result);

                case 17:
                case 'end':
                  return _context.stop();
              }
            }
          }, _callee, this, [[1, 7]]);
        }));

        function send(_x, _x2, _x3) {
          return _ref.apply(this, arguments);
        }

        return send;
      }()
    }, {
      key: 'enqueue',
      value: function enqueue(url, body) {
        this.queue.add(url, body);
        this.flush();
      }

      // @decorate([tsec2jwt, outerDecorator(5000)])

    }, {
      key: 'flush',
      value: function () {
        var _ref2 = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
          var _this2 = this;

          var requestData, endpoint, body, headers;
          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _context2.next = 2;
                  return this.getRequestData();

                case 2:
                  requestData = _context2.sent;

                  if (requestData) {
                    _context2.next = 5;
                    break;
                  }

                  return _context2.abrupt('return');

                case 5:
                  endpoint = requestData.endpoint, body = requestData.body, headers = requestData.headers;

                  // if bulk send is OK, and there are more items, we try to flush the buffer

                  this.send(endpoint, body, headers).then(function () {
                    return _this2.queue.any() && _this2.flush();
                  }).catch(function (error) {
                    console.error('There was a problem while sending data to SEMaaS - ' + error.message);
                  });

                case 7:
                case 'end':
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function flush() {
          return _ref2.apply(this, arguments);
        }

        return flush;
      }()
    }, {
      key: 'flushAll',
      value: function () {
        var _ref3 = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
          var requestData, endpoint, body, headers;
          return regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  _context3.next = 2;
                  return this.getRequestData();

                case 2:
                  requestData = _context3.sent;

                  if (requestData) {
                    _context3.next = 5;
                    break;
                  }

                  return _context3.abrupt('return', Promise.resolve());

                case 5:
                  endpoint = requestData.endpoint, body = requestData.body, headers = requestData.headers;
                  return _context3.abrupt('return', this.send(endpoint, body, headers).catch(function (error) {
                    console.error('There was a problem while sending data to SEMaaS - ' + error.message);
                  }));

                case 7:
                case 'end':
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));

        function flushAll() {
          return _ref3.apply(this, arguments);
        }

        return flushAll;
      }()
    }, {
      key: 'getRequestData',
      value: function () {
        var _ref4 = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
          var validApiKey, bulk, endpoint, apiKey, body, headers;
          return regeneratorRuntime.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  _context4.next = 2;
                  return this.ensureValidApiKey();

                case 2:
                  validApiKey = _context4.sent;

                  if (validApiKey) {
                    _context4.next = 6;
                    break;
                  }

                  console.log('No valid API Key for SEMaaS adapter (' + this.identifier + ') - aborting operation');
                  return _context4.abrupt('return');

                case 6:
                  bulk = this.queue.dump();

                  if (bulk) {
                    _context4.next = 10;
                    break;
                  }

                  console.log('Empty queue for SEMaaS adapter (' + this.identifier + ')');
                  return _context4.abrupt('return');

                case 10:
                  endpoint = bulk[0].endpoint;
                  apiKey = this.apiKey;


                  console.log('Sending queued batch ' + endpoint + ' - ' + apiKey);

                  body = bulk.map(function (operation) {
                    return operation.data;
                  });
                  headers = this.buildApiHeaders();
                  return _context4.abrupt('return', {
                    endpoint: endpoint,
                    body: body,
                    headers: headers
                  });

                case 16:
                case 'end':
                  return _context4.stop();
              }
            }
          }, _callee4, this);
        }));

        function getRequestData() {
          return _ref4.apply(this, arguments);
        }

        return getRequestData;
      }()
    }, {
      key: 'ensureValidApiKey',
      value: function () {
        var _ref5 = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
          return regeneratorRuntime.wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  if (!this.hasApiKey) {
                    _context5.next = 3;
                    break;
                  }

                  console.log('ApiKey OK -> next()');
                  return _context5.abrupt('return', true);

                case 3:
                  if (!this.hasCredentials) {
                    _context5.next = 6;
                    break;
                  }

                  console.log('ApiKey KO, Credentials OK -> getApiKey()');
                  return _context5.abrupt('return', this.getApiKey());

                case 6:

                  console.log('No ApiKey && No Credentials -> KO');
                  return _context5.abrupt('return', false);

                case 8:
                case 'end':
                  return _context5.stop();
              }
            }
          }, _callee5, this);
        }));

        function ensureValidApiKey() {
          return _ref5.apply(this, arguments);
        }

        return ensureValidApiKey;
      }()
    }, {
      key: 'buildApiHeaders',
      value: function buildApiHeaders() {
        var key = void 0;
        var value = void 0;

        switch (this.version.toLowerCase()) {
          case 'v1':
            key = 'Authorization';
            value = 'Bearer ' + this.apiKey;
            break;
          default:
            key = 'Api-Key';
            value = 'jwt ' + this.apiKey;
            break;
        }

        return defineProperty({}, key, value);
      }
    }, {
      key: 'getApiKey',
      value: function () {
        var _ref7 = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
          var consumerId, policy, tsec2JWTEndpoint, headers, host, result, accessToken;
          return regeneratorRuntime.wrap(function _callee6$(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  consumerId = this.consumerId, policy = this.policy, tsec2JWTEndpoint = this.tsec2JWTEndpoint;
                  headers = {
                    'x-consumer-id': consumerId,
                    'x-tsec-token': window.sessionStorage.getItem('tsec'),
                    'x-validation-policy': policy
                  };
                  host = tsec2JWTEndpoint;
                  _context6.next = 5;
                  return Connector.get(host, headers);

                case 5:
                  result = _context6.sent;

                  if (result) {
                    _context6.next = 8;
                    break;
                  }

                  return _context6.abrupt('return', null);

                case 8:
                  accessToken = result.accessToken;


                  this.apiKey = accessToken;
                  return _context6.abrupt('return', accessToken);

                case 11:
                case 'end':
                  return _context6.stop();
              }
            }
          }, _callee6, this);
        }));

        function getApiKey() {
          return _ref7.apply(this, arguments);
        }

        return getApiKey;
      }()
    }, {
      key: 'getEndpoint',
      value: function getEndpoint(host) {
        var region = this.region,
            dnsTld = this.dnsTld,
            version = this.version;


        return host(region, dnsTld, version);
      }
    }, {
      key: 'shouldIncludeLog',
      value: function shouldIncludeLog(logLevel) {
        var applicationLogLevel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_LOG_LEVEL$2;

        var getLogLevel = function getLogLevel(target) {
          return LOG_LEVELS.indexOf(target.toLowerCase());
        };
        var targetLogLevel = getLogLevel(logLevel);
        var minimumLogLevel = getLogLevel(applicationLogLevel);

        return targetLogLevel >= minimumLogLevel;
      }
    }, {
      key: 'hasApiKey',
      get: function get$$1() {
        // @TODO añadir lógica recuperación + persistencia sessionStorage jwt
        return !!this.apiKey;
      }
    }, {
      key: 'hasCredentials',
      get: function get$$1() {
        return !!this.consumerId && !!this.policy && !!this.tsec;
      }
    }, {
      key: 'initialized',
      get: function get$$1() {
        return !!this.omega && !!this.rho;
      }
    }, {
      key: 'omegaEndpoint',
      get: function get$$1() {
        var nameSpace = this.nameSpace;

        var host = this.getEndpoint(OMEGA_HOST);

        return host + '/ns/' + nameSpace + '/logs';
      }
    }, {
      key: 'rhoEndpoint',
      get: function get$$1() {
        var nameSpace = this.nameSpace;

        var host = this.getEndpoint(RHO_HOST);

        return host + '/ns/' + nameSpace + '/spans';
      }
    }, {
      key: 'prefixForChildSpan',
      get: function get$$1() {
        return 'ns/' + this.nameSpace + '/mrs';
      }
    }, {
      key: 'tsec',
      get: function get$$1() {
        return window.sessionStorage.getItem(this.tsecStorageKey);
      }
    }]);
    return SEMaaS;
  }(), (_applyDecoratedDescriptor(_class.prototype, 'flush', [_dec], Object.getOwnPropertyDescriptor(_class.prototype, 'flush'), _class.prototype)), _class));

  return SEMaaS;

})));
//# sourceMappingURL=cells-semaas-adapter.js.map
