import 'regenerator-runtime/runtime';
import Adapters from './adapters';
import Connector from './connector';
import Constants from './constants';
import Utils from './utils';
import Decorators from './decorators';
import Queue from './queue';

const { Omega, Rho } = Adapters;
const {
  SEMAAS: {
    REQUIRED_FIELDS,
    ALLOWED_FIELDS,
    DEFAULT_ADAPTER_IDENTIFIER,
    DEFAULT_ADAPTER_VERSION,
  },
  OMEGA: { HOST: OMEGA_HOST, DEFAULT_LOG_LEVEL, LOG_LEVELS },
  RHO: { HOST: RHO_HOST },
} = Constants;
const { hasProperties } = Utils;
const { outerDecorator } = Decorators;

export default class SEMaaS {
  constructor(config) {
    // configurable properties by constructor
    this.nameSpace = null;

    this.identifier = DEFAULT_ADAPTER_IDENTIFIER;

    this.mrId = null;

    this.consumerId = null;

    this.policy = null;

    this.region = null;

    this.dnsTld = null;

    this.version = DEFAULT_ADAPTER_VERSION;

    this.tsec2JWTEndpoint = null;

    this.logLevel = DEFAULT_LOG_LEVEL;

    // properties that belong to semaas life cycle and rely on configurable properties
    this.apiKey = null;

    // composition entitys
    this.omega = null;

    this.rho = null;

    this.queue = null;

    this.tsecStorageKey = 'tsec'; // sessionStorage key for recovery the tsec id
    this.setup(config);
  }

  setup(config) {
    if (!config || !this.validateConfig(config, REQUIRED_FIELDS)) {
      throw new Error(`Invalid setup for SEMaaS adapter (${this.identifier}). Required fields: ${REQUIRED_FIELDS.join(', ')}.`);
    }

    this.initialize(config);
  }

  validateConfig(config, expectedFields) {
    return hasProperties(config, expectedFields);
  }

  initialize(config) {
    ALLOWED_FIELDS.forEach((field) => {
      if (config[field]) {
        this[field] = config[field];
      }
    });

    const {
      nameSpace,
      identifier,
      mrId,
      tsec2JWTEndpoint,
      region,
      dnsTld,
      version,
      logLevel,
      tsecStorageKey,
    } = this;

    this.omega = new Omega(mrId);
    this.rho = new Rho(mrId);
    this.queue = new Queue(identifier);

    console.info(`SEMaaS adapter for ${region} (TSEC: ${tsec2JWTEndpoint}) [${dnsTld} - ${version}] (${identifier} - ns: ${nameSpace}, mrId: ${mrId}) [logLevel: ${logLevel}] [tsecStorageKey: ${tsecStorageKey}] successfully initialized.`);
  }

  log(obj) {
    const data = this.omega.createLog(obj);

    if (this.shouldIncludeLog(data.level, this.logLevel)) {
      this.enqueue(this.omegaEndpoint, data);
    }
  }

  ingest(spans) {
    const data = this.rho.buildSpans(spans);

    this.enqueue(this.rhoEndpoint, data);
  }

  createSpan(data) {
    const span = this.rho.createSpan(data, this.prefixForChildSpan);

    return span;
  }

  createUUID() {
    const UUID = this.rho.createUUID();

    return UUID;
  }

  async send(url, body, headers) {
    let result;

    try {
      result = await Connector.post(url, body, headers);
    } catch (e) { }

    if (!result) {
      console.log('There was a problem while sending data to SEMaaS - operation will be queued.');
      this.enqueue(url, body);
    } else if(result.status === 400){
      throw new Error(result.message);
    }

    return result;
  }

  enqueue(url, body) {
    this.queue.add(url, body);
    this.flush();
  }

  // @decorate([tsec2jwt, outerDecorator(5000)])
  @outerDecorator(5000)
  async flush() {
    const requestData = await this.getRequestData();

    if (!requestData) {
      return;
    }

    const { endpoint, body, headers } = requestData;

    // if bulk send is OK, and there are more items, we try to flush the buffer
    this.send(endpoint, body, headers).then(() => this.queue.any() && this.flush()).catch((error)=>{console.error(`There was a problem while sending data to SEMaaS - ${error.message}`)});
  }

  async flushAll() {
    const requestData = await this.getRequestData();

    if (!requestData) {
      return Promise.resolve();
    }

    const { endpoint, body, headers } = requestData;

    return this.send(endpoint, body, headers).catch((error)=>{console.error(`There was a problem while sending data to SEMaaS - ${error.message}`)});
  }

  async getRequestData() {
    const validApiKey = await this.ensureValidApiKey();

    if (!validApiKey) {
      console.log(`No valid API Key for SEMaaS adapter (${this.identifier}) - aborting operation`);
      return;
    }

    const bulk = this.queue.dump();

    if (!bulk) {
      console.log(`Empty queue for SEMaaS adapter (${this.identifier})`);
      return;
    }

    const { endpoint } = bulk[0];
    const { apiKey } = this;

    console.log(`Sending queued batch ${endpoint} - ${apiKey}`);

    const body = bulk.map(operation => operation.data);
    const headers = this.buildApiHeaders();

    return {
      endpoint,
      body,
      headers,
    };
  }

  async ensureValidApiKey() {
    if (this.hasApiKey) {
      console.log('ApiKey OK -> next()');
      return true;
    } if (this.hasCredentials) {
      console.log('ApiKey KO, Credentials OK -> getApiKey()');
      return this.getApiKey();
    }

    console.log('No ApiKey && No Credentials -> KO');
    return false;
  }

  buildApiHeaders() {
    let key;
    let value;

    switch (this.version.toLowerCase()) {
      case 'v1':
        key = 'Authorization';
        value = `Bearer ${this.apiKey}`;
        break;
      default:
        key = 'Api-Key';
        value = `jwt ${this.apiKey}`;
        break;
    }

    return { [key]: value };
  }

  async getApiKey() {
    const {
      consumerId,
      policy,
      tsec2JWTEndpoint,
    } = this;
    const headers = {
      'x-consumer-id': consumerId,
      'x-tsec-token': window.sessionStorage.getItem('tsec'),
      'x-validation-policy': policy,
    };
    const host = tsec2JWTEndpoint;
    const result = await Connector.get(host, headers);

    if (!result) {
      return null;
    }

    const { accessToken } = result;

    this.apiKey = accessToken;
    return accessToken;
  }

  get hasApiKey() {
    // @TODO añadir lógica recuperación + persistencia sessionStorage jwt
    return !!this.apiKey;
  }

  get hasCredentials() {
    return !!this.consumerId && !!this.policy && !!this.tsec;
  }

  get initialized() {
    return !!this.omega && !!this.rho;
  }

  get omegaEndpoint() {
    const { nameSpace } = this;
    const host = this.getEndpoint(OMEGA_HOST);

    return `${host}/ns/${nameSpace}/logs`;
  }

  get rhoEndpoint() {
    const { nameSpace } = this;
    const host = this.getEndpoint(RHO_HOST);

    return `${host}/ns/${nameSpace}/spans`;
  }

  get prefixForChildSpan() {
    return `ns/${this.nameSpace}/mrs`;
  }

  get tsec() {
    return window.sessionStorage.getItem(this.tsecStorageKey);
  }

  getEndpoint(host) {
    const { region, dnsTld, version } = this;

    return host(region, dnsTld, version);
  }

  shouldIncludeLog(logLevel, applicationLogLevel = DEFAULT_LOG_LEVEL) {
    const getLogLevel = target => LOG_LEVELS.indexOf(target.toLowerCase());
    const targetLogLevel = getLogLevel(logLevel);
    const minimumLogLevel = getLogLevel(applicationLogLevel);

    return (targetLogLevel >= minimumLogLevel);
  }
}
